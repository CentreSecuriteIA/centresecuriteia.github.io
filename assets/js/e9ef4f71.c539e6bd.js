"use strict";(self.webpackChunkatlas=self.webpackChunkatlas||[]).push([[3726],{8051:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>o,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"chapters/08/1","title":"Oversight","description":"Why do we need oversight? As AI systems get smarter, they will start doing tasks that are hard for humans to evaluate. Evaluation means checking how well the AI did after completing a task, while feedback is the information we give to the AI during or after it works to help it learn and improve. Right now, we can still use methods like Reinforcement Learning from Human Feedback (RLHF) to guide AI in the right direction. But we can only give feedback if we can still evaluate the outputs. As tasks get more complex, even experts might struggle to provide accurate evaluations and feedback. So, we need new ways to give accurate feedback, even for tasks that are beyond human expertise. This is the goal of scalable oversight.","source":"@site/docs/chapters/08/01.md","sourceDirName":"chapters/08","slug":"/chapters/08/01","permalink":"/chapters/08/01","draft":false,"unlisted":false,"editUrl":"https://github.com/markov-root/atlas/edit/main/docs/chapters/08/01.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"1","title":"Oversight","sidebar_label":"8.1 Oversight","sidebar_position":2,"slug":"/chapters/08/01","reading_time_core":"10 min","reading_time_optional":"1 min","pagination_prev":"chapters/08/index","pagination_next":"chapters/08/2"},"sidebar":"docs","previous":{"title":"Scalable Oversight","permalink":"/chapters/08/"},"next":{"title":"8.2 Task Decomposition","permalink":"/chapters/08/02"}}');var a=n(4848),s=n(8453),r=(n(2482),n(8559),n(1966),n(2501));const o={id:1,title:"Oversight",sidebar_label:"8.1 Oversight",sidebar_position:2,slug:"/chapters/08/01",reading_time_core:"10 min",reading_time_optional:"1 min",pagination_prev:"chapters/08/index",pagination_next:"chapters/08/2"},l="Oversight",c={},h=[{value:"Training Signals",id:"01",level:2},{value:"Verification vs. Generation",id:"02",level:2}];function d(e){const i={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{GlossaryTerm:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"oversight",children:"Oversight"})}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Why do we need oversight?"})," As AI systems get smarter, they will start doing tasks that are hard for humans to evaluate. Evaluation means checking how well the AI did after completing a task, while feedback is the information we give to the AI during or after it works to help it learn and improve. Right now, we can still use methods like Reinforcement Learning from Human Feedback (RLHF) to guide AI in the right direction. But we can only give feedback if we can still evaluate the outputs. As tasks get more complex, even experts might struggle to provide accurate evaluations and feedback. So, we need new ways to give accurate feedback, even for tasks that are beyond human expertise. This is the goal of scalable oversight."]}),"\n",(0,a.jsx)(i.p,{children:"Scalable Oversight techniques help humans provide accurate feedback on tasks to ensure AI systems are aligned with our goals, even after the task complexity outstrips the ability of the best human experts. This can happen during the AI's training or deployment and isn't limited to RLHF-style feedback."}),"\n",(0,a.jsx)(r.A,{src:"./img/6Sn_Image_1.png",alt:"Enter image alt description",number:"1",label:"8.1",caption:"The difference between regular oversight safety research, and scalable oversight safety research."}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Aligning RL Agents vs. LLMs."})," A few years ago it looked like the path to AGI was by training deep RL agents from scratch in a wide range of games and multi-agent environments. These agents would be aligned to maximizing simple score functions such as survival and winning games and wouldn\u2019t know much about human values. Aligning the resulting agents would require a lot of effort: not only do we have to create a human-aligned ",(0,a.jsx)(n,{term:"loss function",definition:'{"definition":"A function that measures how well a model\'s predictions match the actual target values, used to guide training.","source":"","aliases":["Loss Function","cost function","objective function"]}',children:(0,a.jsx)(n,{term:"loss function",definition:'{"definition":"A function that measures how well a model\'s predictions match the actual target values, used to guide training.","source":"","aliases":["Loss Function","cost function","objective function"]}',children:"objective function"})})," from scratch, we\u2019d likely also need to instill new capabilities into the agents like understanding human society, what humans care about, and how humans think. Large language models (LLMs) make this a lot easier: they come preloaded with a lot of humanity\u2019s knowledge, including detailed knowledge about human preferences and values. Out of the box they aren\u2019t agents who are trying to pursue their own goals in the world, and their objective functions are quite malleable. For example, they are surprisingly easy to train to behave more nicely. If AGI comes out of LLMs it might be easier to align. (",(0,a.jsx)(i.a,{href:"https://aligned.substack.com/p/alignment-optimism",children:"Leike, 2022"}),")"]}),"\n",(0,a.jsx)(i.h2,{id:"01",children:"Training Signals"}),"\n",(0,a.jsx)(i.p,{children:"Before we understand how to actually align smarter than human AIs, we need to understand the general concept of training signals and why they are getting increasingly harder to generate as AI is starting to display higher levels of general purpose capabilities."}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"What are training signals?"})," Training signals is a general term that we use for inputs that are used to guide AI learning. They can be rewards, labels, or evaluations indicating how well the AI is performing a task. For example:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:["In ",(0,a.jsx)(n,{term:"supervised learning",definition:'{"definition":"A machine learning approach where the model learns from labeled training data to make predictions on new, unseen data.","source":"","aliases":["Supervised Learning"]}',children:(0,a.jsx)(n,{term:"supervised learning",definition:'{"definition":"A machine learning approach where the model learns from labeled training data to make predictions on new, unseen data.","source":"","aliases":["Supervised Learning"]}',children:"supervised learning"})})," (SL), the training signal is the correct label for each example."]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:["For large language models (LLMs) using self-",(0,a.jsx)(n,{term:"supervised learning",definition:'{"definition":"A machine learning approach where the model learns from labeled training data to make predictions on new, unseen data.","source":"","aliases":["Supervised Learning"]}',children:(0,a.jsx)(n,{term:"supervised learning",definition:'{"definition":"A machine learning approach where the model learns from labeled training data to make predictions on new, unseen data.","source":"","aliases":["Supervised Learning"]}',children:"supervised learning"})})," (SSL), training signals are the correct next word in a sentence during ",(0,a.jsx)(n,{term:"pre-training",definition:'{"definition":"The initial training phase where a model learns general representations from a large dataset before being adapted to specific tasks.","source":"","aliases":["Pre-training","pretraining"]}',children:(0,a.jsx)(n,{term:"pre-training",definition:'{"definition":"The initial training phase where a model learns general representations from a large dataset before being adapted to specific tasks.","source":"","aliases":["Pre-training","pretraining"]}',children:"pre-training"})}),". Human feedback on the quality of responses during ",(0,a.jsx)(n,{term:"fine-tuning",definition:'{"definition":"The process of taking a pre-trained model and further training it on a specific task or dataset.","source":"","aliases":["Fine-tuning","fine-tune","finetuning","finetune"]}',children:(0,a.jsx)(n,{term:"fine-tuning",definition:'{"definition":"The process of taking a pre-trained model and further training it on a specific task or dataset.","source":"","aliases":["Fine-tuning","fine-tune","finetuning","finetune"]}',children:"fine-tuning"})})," is also a type of training signal guiding the outputs in a direction we want (a more \u201caligned\u201d direction)."]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"In reinforcement learning (RL), training signals are rewards based on the success/failure of actions (or multiple actions), like points scored in a game or successful navigation to a location."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"These signals shape how AI systems learn and are used to both evaluate performance and provide feedback."}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Easy-to-generate training signals."})," For some tasks, generating training signals is simple. AlphaGo Zero, an RL agent playing Go, is a good example of this. The game has clear rules and win/loss outcomes, so training signals are straightforward: algorithmically generated win and lose signals directly measure performance, making it easy for the model to learn and improve its gameplay."]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Hard-to-generate training signals."})," For other tasks, creating training signals is much harder. For example, training GPT models to generate accurate text summaries is challenging. The AI needs to convey correct information while being coherent and interesting. Success is subjective. Since it depends on individual reader preferences, it is hard to define clear, algorithmically generated training signals. Another example is self-driving cars navigating through busy city streets. These cars need to make real-time decisions, and the training signals or rewards for safe and efficient navigation are difficult to define due to varying contexts and sometimes conflicting traffic laws and safety considerations."]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Fuzzy tasks."})," We call tasks where training signals are hard to generate \u201cfuzzy tasks\u201c. These tasks generally have ambiguous or ill-defined objectives and outcomes. We can\u2019t generate precise training signals due to inherent subjectivity and variability in \u201ccorrect responses\u201d. Fuzzy tasks lack clear, objective criteria for success. Unlike well-defined tasks with specific, measurable goals, fuzzy tasks are more open-ended, which complicates our job of coming up with training signals. If it's difficult to provide precise rewards or labels that accurately capture the desired behavior, the training process becomes complicated. AI systems might not receive the consistent, reliable feedback needed to learn effectively. This is essentially highlighting again the difficulty of the reward specification problem that we talked about in previous chapters."]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Fuzzy tasks and Scalable Oversight."})," Fuzzy tasks are closely related to AI alignment, where ensuring AI systems act in accordance with human values and intentions is challenging due to ambiguity and subjectivity. Aligning AI with human values is a fuzzy task. Oversight techniques aim to solve alignment by providing training signals for fuzzy tasks, including feedback and imitation learning techniques like RLHF, Constitutional AI (CAI), and Inverse Reinforcement Learning (IRL). Scalable oversight techniques aim to provide training signals for fuzzy tasks that are too complex for even experts to understand or evaluate."]}),"\n",(0,a.jsx)(i.p,{children:"To make scalable oversight techniques viable verification needs to be easier than generation, and preferably (but not necessarily) tasks should be decomposable. These properties will be discussed in the next sections."}),"\n",(0,a.jsx)(i.h2,{id:"02",children:"Verification vs. Generation"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"What Does P \u2260 NP Mean?"})," In computer science, we classify problems based on how hard they are to solve (generate a solution) and how hard they are to check (verify a solution)."]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"P (Polynomial time): These are problems that a computer can solve quickly."}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"NP (Nondeterministic Polynomial time): These are problems where, if you have a solution, you can check it quickly, but finding the solution might take a long time."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"What is generation?"})," Generation is the process of coming up with solutions from scratch. This means searching through many possibilities, which can take a lot of time and computing power. For example, solving a Sudoku puzzle involves filling a 9x9 grid with numbers so that each row, column, and 3x3 subgrid contains all the digits from 1 to 9 without repeating. If you've ever tried to solve a Sudoku puzzle, you know it involves a lot of trial and error to make sure all the rules are followed."]}),"\n",(0,a.jsx)(r.A,{src:"./img/ip2_Image_2.png",alt:"Enter image alt description",number:"2",label:"8.2",caption:"Example of an empty sudoku board ([Wikipedia](https://en.wikipedia.org/wiki/Sudoku)). Filling this in would be harder than checking if the solved version below is correct."}),"\n",(0,a.jsx)(i.p,{children:"Generation here involves filling in the blank grid while ensuring all the constraints (unique numbers in rows, columns, and subgrids) are satisfied."}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"What is verification?"})," Verification is the process of checking whether a given solution attempt is correct. Using the Sudoku example, verification means making sure that each row, column, and subgrid contains all the digits from 1 to 9 without any repeats. Once someone gives you a completed Sudoku puzzle, checking whether it's correct is straightforward and quick. This idea is central to the concept of P \u2260 NP."]}),"\n",(0,a.jsx)(r.A,{src:"./img/ojk_Image_3.png",alt:"Enter image alt description",number:"3",label:"8.3",caption:"Example of a filled in sudoku board ([Wikipedia](https://en.wikipedia.org/wiki/Sudoku)). Its very easy comparatively to see that the solution is correct."}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Examples: Illustrating Verification is Easier Than Generation."})," This is a very general property that holds across many domains:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:["Formal Problems: In computational complexity theory, most computer scientists believe that P \u2260 NP (",(0,a.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/P_versus_NP_problem#Reasons_to_believe_P_%E2%89%A0_NP_or_P_=_NP",children:"Wikipedia"}),"), which means there are many problems where checking a solution is easier than finding one. This is seen in tasks like solving SAT problems or graph algorithms."]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Sports and Games: It's easier to look at a football scoreboard to see who is winning than it is to play the game well."}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Consumer Products: Comparing the quality of smartphones based on user reviews is simpler than designing and building a new smartphone."}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Job Performance: Evaluating how well an employee is doing is less demanding than actually doing the job."}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Academic Research: While reviewing research can be tough, it's still less work than producing new research."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Why Verification Being Easier Than Generation Matters for Scalable Oversight."})," This fact is crucial for scalable oversight because it allows us as human overseers to efficiently ensure the correctness and safety of outputs produced by complex systems without needing to fully understand or replicate the entire generation process. If P \u2260 NP is true , it implies that we might be able to trust and delegate alignment research itself to AI models, because we can comparatively easily verify that their solutions work while they have to do the hard task of generating the solutions to alignment. Overall operating under this assumption can make the task of aligning advanced AI systems seem more feasible. The next few paragraphs go into the debate of how valid this assumption is."]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Verification in Adversarial Contexts."})," When verifying something in situations where someone might be actively trying to trick or attack you, the process becomes much harder. Put another way, if we have AIs that are deceptive, the problem becomes significantly trickier. For example, making sure software is secure against all possible attacks can be tougher than writing the software in the first place. An attacker only needs to find one security hole, but the person verifying must check everything to ensure there are no holes. This makes verification very challenging. Similarly creating a secure system in cryptography is hard, but proving that it\u2019s secure against all possible attacks is even more difficult. You need to consider every potential way someone might try to break the system, which is a huge task."]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Easier than generation does not mean verification is trivial."})," Just because verification is theoretically easier than generation doesn\u2019t mean it\u2019s always easy in practice. For example, checking a complex mathematical proof can be very hard. Writing the proof takes creativity and deep understanding, but verifying it requires careful and detailed checking, which can be exhausting and prone to mistakes. In the case of software, writing secure software is challenging, but verifying that it\u2019s completely secure is even harder. Even though verifying a problem\u2019s solution might be easier than generating the solution, the process can still be very difficult and require significant effort and expertise."]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Verification of Safety vs. Provable Alignment."})," In the event that we have to deal with superintelligent AI, just verifying its behavior might not be enough. Some researchers argue that we need to prove that the AI will always act in ways that align with human values. Verification means checking whether the AI behaves correctly in specific situations. Provable alignment means giving solid evidence that the AI will act correctly in every possible situation, even new and unexpected ones. This requires more than just checking\u2014it needs formal methods and guarantees, which is extremely difficult."]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Verification vs. Mathematical Proof."})," Verification involves checking if a specific solution is correct, usually through testing or inspection. A mathematical proof, on the other hand, is a rigorous logical argument that shows a statement is always true. For example, verifying a Sudoku solution checks if the given arrangement is correct, while a mathematical proof might show that any Sudoku puzzle with a certain number of clues always has a unique solution."]})]})}function g(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);